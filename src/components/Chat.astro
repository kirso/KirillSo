---
import { ClientRouter } from "astro:transitions";
export const prerender = false;

interface Props {
	initialMessage?: string;
}

const { initialMessage = "Hi! Ask me anything about my experience and background." } = Astro.props;
---

<ClientRouter />

<div class="fixed right-4 bottom-4 z-50" transition:persist>
	<chat-component data-initial-message={initialMessage}>
		<button
			class="chat-toggle bg-accent text-bgColor rounded-full px-4 py-2 font-bold transition-opacity hover:opacity-80"
			aria-label="Toggle chat"
		>
			Chat
		</button>

		<div
			class="chat-window absolute right-0 bottom-16 flex hidden max-h-96 w-80 flex-col overflow-hidden rounded-lg border border-gray-300 bg-white shadow-lg dark:border-gray-700 dark:bg-gray-900"
		>
			<div
				class="flex items-center justify-between border-b border-gray-300 bg-gray-50 p-2 dark:border-gray-700 dark:bg-gray-800"
			>
				<span class="font-bold text-gray-900 dark:text-white">Chat with me</span>
				<button
					class="chat-close text-gray-700 hover:opacity-80 dark:text-gray-300"
					aria-label="Close chat"
				>
					<svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
						<path
							d="M6.28 5.22a.75.75 0 00-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 101.06 1.06L10 11.06l3.72 3.72a.75.75 0 101.06-1.06L11.06 10l3.72-3.72a.75.75 0 00-1.06-1.06L10 8.94 6.28 5.22z"
						></path>
					</svg>
				</button>
			</div>

			<div
				class="messages-container flex-grow space-y-2 overflow-y-auto bg-white p-4 dark:bg-gray-900"
			>
				<div
					class="mr-auto max-w-[80%] rounded-lg bg-gray-100 p-2 text-gray-800 dark:bg-gray-800 dark:text-gray-200"
				>
					{initialMessage}
				</div>
			</div>

			<form
				class="border-t border-gray-300 bg-white p-2 dark:border-gray-700 dark:bg-gray-900"
				method="POST"
				action="/api/chat"
				data-streaming
			>
				<div class="relative">
					<input
						type="text"
						name="message"
						placeholder="Type your message..."
						class="focus:ring-accent mb-2 w-full rounded-lg border border-gray-300 bg-white p-2 pr-10 text-gray-900 focus:ring-2 focus:outline-none disabled:opacity-50 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-200"
						required
					/>
				</div>
				<button
					type="submit"
					class="bg-accent text-bgColor w-full rounded-lg px-4 py-2 font-bold transition-opacity hover:opacity-80 disabled:cursor-not-allowed disabled:opacity-50"
				>
					Send
				</button>
			</form>
		</div>
	</chat-component>
</div>

<style>
	.messages-container::-webkit-scrollbar {
		width: 6px;
	}

	.messages-container::-webkit-scrollbar-track {
		background: transparent;
	}

	.messages-container::-webkit-scrollbar-thumb {
		background-color: rgba(155, 155, 155, 0.5);
		border-radius: 20px;
	}

	.dot-flashing {
		position: relative;
		width: 6px;
		height: 6px;
		border-radius: 3px;
		background-color: currentColor;
		animation: dot-flashing 1s infinite linear alternate;
		animation-delay: 0.5s;
	}

	.dot-flashing::before,
	.dot-flashing::after {
		content: "";
		display: inline-block;
		position: absolute;
		top: 0;
	}

	.dot-flashing::before {
		left: -10px;
		width: 6px;
		height: 6px;
		border-radius: 3px;
		background-color: currentColor;
		animation: dot-flashing 1s infinite alternate;
		animation-delay: 0s;
	}

	.dot-flashing::after {
		left: 10px;
		width: 6px;
		height: 6px;
		border-radius: 3px;
		background-color: currentColor;
		animation: dot-flashing 1s infinite alternate;
		animation-delay: 1s;
	}

	@keyframes dot-flashing {
		0% {
			background-color: currentColor;
		}
		50%,
		100% {
			background-color: rgba(155, 155, 155, 0.2);
		}
	}
</style>

<script>
	class ChatComponent extends HTMLElement {
		private isStreaming = false;
		private form: HTMLFormElement | null = null;
		private input: HTMLInputElement | null = null;
		private submitBtn: HTMLButtonElement | null = null;
		private messagesContainer: HTMLElement | null = null;
		private chatWindow: HTMLElement | null = null;

		constructor() {
			super();
			this.setupChat();
		}

		private setupChat() {
			const toggleBtn = this.querySelector(".chat-toggle");
			const closeBtn = this.querySelector(".chat-close");

			// Store elements as class properties with type assertions
			this.chatWindow = this.querySelector(".chat-window");
			this.messagesContainer = this.querySelector(".messages-container");
			const form = this.querySelector("form");
			if (!form) return;
			this.form = form;

			const input = form.querySelector("input");
			const submitBtn = form.querySelector("button");

			if (input && submitBtn) {
				this.input = input;
				this.submitBtn = submitBtn;
			}

			toggleBtn?.addEventListener("click", () => {
				this.chatWindow?.classList.toggle("hidden");
				this.input?.focus();
			});

			closeBtn?.addEventListener("click", () => {
				this.chatWindow?.classList.add("hidden");
			});

			this.form.addEventListener("submit", async (e) => {
				e.preventDefault();
				if (this.isStreaming || !this.form) return;

				const formData = new FormData(this.form);
				const message = formData.get("message")?.toString();

				if (!message) return;

				this.setLoading(true);
				this.addMessage(message, true);
				this.form?.reset();

				try {
					const response = await fetch("/api/chat", {
						method: "POST",
						body: formData,
					});

					if (response.status === 429) {
						this.addMessage(
							"You've sent too many messages. Please wait a minute and try again.",
							false,
						);
						return;
					}

					if (!response.ok) throw new Error("Failed to send message");

					const reader = response.body?.getReader();
					if (!reader) throw new Error("No response stream");

					this.isStreaming = true;
					let accumulatedMessage = "";

					// Add loading indicator to chat
					this.addLoadingIndicator();

					while (true) {
						const { done, value } = await reader.read();
						if (done) break;

						const chunk = new TextDecoder().decode(value);
						accumulatedMessage += chunk;
						this.updateStreamingMessage(accumulatedMessage);
					}

					this.isStreaming = false;
				} catch (error) {
					console.error("Chat error:", error);
					this.addMessage("Sorry, there was an error processing your request.", false);
				} finally {
					this.setLoading(false);
					// Remove loading indicator if it exists
					this.removeLoadingIndicator();
				}
			});
		}

		private setLoading(loading: boolean) {
			if (loading) {
				this.input?.setAttribute("disabled", "");
				this.submitBtn?.setAttribute("disabled", "");
			} else {
				this.input?.removeAttribute("disabled");
				this.submitBtn?.removeAttribute("disabled");
			}
		}

		private addLoadingIndicator() {
			// Remove existing loading indicator if any
			this.removeLoadingIndicator();

			// Create and add loading indicator in the messages area
			const loadingDiv = document.createElement("div");
			loadingDiv.className =
				"loading-indicator max-w-[80%] p-2 rounded-lg mr-auto bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300";

			const typingIndicator = document.createElement("div");
			typingIndicator.className = "typing-indicator";

			const dotFlashing = document.createElement("div");
			dotFlashing.className = "dot-flashing";

			typingIndicator.appendChild(dotFlashing);
			loadingDiv.appendChild(typingIndicator);

			this.messagesContainer?.appendChild(loadingDiv);
			this.messagesContainer?.scrollTo(0, this.messagesContainer.scrollHeight);
		}

		private removeLoadingIndicator() {
			const loadingIndicator = this.messagesContainer?.querySelector(".loading-indicator");
			if (loadingIndicator) {
				loadingIndicator.remove();
			}
		}

		private addMessage(text: string, isUser: boolean) {
			if (!this.messagesContainer) return;

			const messageDiv = document.createElement("div");
			messageDiv.className = `max-w-[80%] p-2 rounded-lg ${
				isUser
					? "ml-auto bg-accent text-white"
					: "mr-auto bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-200"
			}`;
			messageDiv.textContent = text;
			this.messagesContainer?.appendChild(messageDiv);
			this.messagesContainer?.scrollTo(0, this.messagesContainer.scrollHeight);
		}

		private updateStreamingMessage(text: string) {
			if (!this.messagesContainer) return;

			// Remove the loading indicator before updating streaming message
			this.removeLoadingIndicator();

			let streamingMessage = this.messagesContainer?.querySelector(".streaming-message");

			if (!streamingMessage) {
				streamingMessage = document.createElement("div");
				streamingMessage.className =
					"streaming-message max-w-[80%] p-2 rounded-lg mr-auto bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-200";
				this.messagesContainer?.appendChild(streamingMessage);
			}

			streamingMessage.textContent = text;
			this.messagesContainer?.scrollTo(0, this.messagesContainer.scrollHeight);
		}
	}

	customElements.define("chat-component", ChatComponent);
</script>
